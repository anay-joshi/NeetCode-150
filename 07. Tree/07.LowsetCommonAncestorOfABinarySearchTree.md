# 235. Lowest Common Ancestor of a Binary Search Tree
Easy


Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

 

Example 1:
```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```
Example 2:
```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```
Example 3:
``
Input: root = [2,1], p = 2, q = 1
Output: 2
 ``

Constraints:

- The number of nodes in the tree is in the range `[2, 105]`.
- -10<sup>9</sup> <= Node.val <= 10<sup>9</sup>
- All Node.val are unique.
- p != q
- p and q will exist in the BST.
# Lowest Common Ancestor of a Binary Search Tree

## Problem
Given a Binary Search Tree (BST) and two nodes `p` and `q`, find their
Lowest Common Ancestor (LCA).

The LCA of two nodes is the lowest node in the tree that has both nodes
as descendants (a node can be a descendant of itself).

---

## Key Insight (BST Property)
In a BST:
- All values in the left subtree are **less than** the node’s value
- All values in the right subtree are **greater than** the node’s value

Using this ordering, we can decide the direction to move without exploring
both subtrees.

---

## Optimized Approach

Starting from the root:

1. If both `p` and `q` are **less than** the current node  
   → move to the left subtree
2. If both `p` and `q` are **greater than** the current node  
   → move to the right subtree
3. Otherwise  
   → the current node is the **Lowest Common Ancestor**

The first node where `p` and `q` split (or match) is the LCA.

---

## Algorithm
1. Start at the root.
2. While the current node is not null:
   - If `p.val` and `q.val` are both smaller, go left.
   - If `p.val` and `q.val` are both larger, go right.
   - Else, return the current node.
3. Return the found node as the LCA.

---

## Java Implementation (Iterative)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while (root != null) {
            if (p.val < root.val && q.val < root.val) {
                root = root.left;
            } else if (p.val > root.val && q.val > root.val) {
                root = root.right;
            } else {
                return root;
            }
        }
        return null;
    }
}
```

## Alternative (Recursive)
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return null;

        if (p.val < root.val && q.val < root.val) {
            return lowestCommonAncestor(root.left, p, q);
        } else if (p.val > root.val && q.val > root.val) {
            return lowestCommonAncestor(root.right, p, q);
        }

        return root;
    }
}
```

## Complexity Analysis

### Time Complexity: O(H)

O(log N) for a balanced BST

O(N) in the worst case (skewed tree)

### Space Complexity:

Iterative: O(1)

Recursive: O(H) due to call stack

## Notes

This solution relies on BST ordering; it does not apply to a general binary tree.

Iterative and recursive versions are logically equivalent; the difference is space usage.
