# [124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)
Hard


A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.

The path sum of a path is the sum of the node's values in the path.

Given the root of a binary tree, return the maximum path sum of any non-empty path.

 

Example 1:
```
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.
```
Example 2:
```
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.
 ```

Constraints:
- The number of nodes in the tree is in the range [1, 3 * 104].
- -1000 <= Node.val <= 1000
# Construct Binary Tree from Preorder and Inorder Traversal

## Problem
Given two integer arrays `preorder` and `inorder` where:
- `preorder` represents the preorder traversal of a binary tree
- `inorder` represents the inorder traversal of the same tree

Construct and return the binary tree.

---

## Key Insight

- In **preorder traversal**, the first element is always the root.
- In **inorder traversal**, the root splits the tree into:
  - Left subtree elements
  - Right subtree elements

By combining both:
- Preorder determines **which node to build next**
- Inorder determines **where to split subtrees**

---

## Optimized Approach

To avoid repeatedly searching in the inorder array:

- Build a **HashMap** from value → index in inorder
- Maintain a global `preorderIndex` pointer
- Recursively construct subtrees using inorder boundaries

---

## Algorithm

1. Build a map of inorder value → index.
2. Maintain a pointer `preorderIndex` starting at 0.
3. Recursively:
   - Pick current root from `preorder[preorderIndex++]`
   - Find its index in inorder using the map
   - Recursively build:
     - Left subtree → `(left, inorderIndex - 1)`
     - Right subtree → `(inorderIndex + 1, right)`
4. Stop recursion when `left > right`.

---

## Java Implementation

```java
class Solution {
    private int preorderIndex = 0;
    private Map<Integer, Integer> inorderMap;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        inorderMap = new HashMap<>();

        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }

        return build(preorder, 0, inorder.length - 1);
    }

    private TreeNode build(int[] preorder, int left, int right) {

        if (left > right) return null;

        int rootVal = preorder[preorderIndex++];
        TreeNode root = new TreeNode(rootVal);

        int inorderIdx = inorderMap.get(rootVal);

        root.left = build(preorder, left, inorderIdx - 1);
        root.right = build(preorder, inorderIdx + 1, right);

        return root;
    }
}

```
## Complexity Analysis
```
- Time Complexity: O(n)
- Space Complexity: O(logn), recursive call stacks
```
