# 102. Binary Tree Level Order Traversal
Medium


Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

 

Example 1:

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```
Example 2:
```
Input: root = [1]
Output: [[1]]
```
Example 3:
```
Input: root = []
Output: []
``` 

Constraints:

- The number of nodes in the tree is in the range [0, 2000].
- -1000 <= Node.val <= 1000

# Binary Tree Level Order Traversal

## Problem
Given the root of a binary tree, return the level order traversal of its nodesâ€™ values.
(Level by level, from left to right.)

---

## Key Insight
Level order traversal is a **Breadth-First Search (BFS)** problem.

- BFS naturally processes nodes **level by level**
- A **queue** is used to maintain FIFO order
- To separate levels, we process exactly the number of nodes currently in the queue

---

## Optimized Approach (BFS with Queue)

1. Use a queue to store nodes of the current level.
2. Before processing a level, **store the current queue size**.
3. Process exactly that many nodes:
   - These nodes belong to the same level.
4. While processing, add children to the queue (next level).

---

## Important Rule
> **Never use `queue.size()` directly inside the loop when modifying the queue.**  
Always store it in a variable before the loop.

---

## Algorithm
1. If root is null, return an empty list.
2. Initialize a queue and add the root.
3. While the queue is not empty:
   - Record `levelSize = queue.size()`
   - Create a new list for the current level
   - Loop `levelSize` times:
     - Remove a node from the queue
     - Add its value to the current level
     - Add its left and right children to the queue if they exist
   - Add the level list to the result
4. Return the result.

---

## Java Implementation

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) return result;

        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<Integer> level = new ArrayList<>();

            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);

                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }

            result.add(level);
        }

        return result;
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(N)
- Space Complexity: O(N), max number of nodes in a level
```
