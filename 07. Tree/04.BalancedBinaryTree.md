# 110. Balanced Binary Tree
Easy

Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

a binary tree in which the left and right subtrees of every node differ in height by no more than 1.

 

Example 1:
```
Input: root = [3,9,20,null,null,15,7]
Output: true
```

Example 2:
```
Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
```

Example 3:
```
Input: root = []
Output: true
```

Constraints:
- The number of nodes in the tree is in the range [0, 5000].
- -104 <= Node.val <= 104


# Balanced Binary Tree

## Problem
A binary tree is height-balanced if, for every node, the height difference between
its left and right subtrees is at most 1.

---

## Key Insight
Balance must be checked at **every node**, not just the root.

If at any node:
|height(left) - height(right)| > 1

the tree is not balanced.

---

## Brute Force Approach
- For each node:
  - Compute height of left subtree
  - Compute height of right subtree
  - Check balance condition
- Recursively repeat for all nodes

**Time Complexity:** O(NÂ²)  
**Space Complexity:** O(H)

---

## Optimized Approach (Single DFS)

- Perform postorder DFS
- DFS returns:
  - subtree height if balanced
  - `-1` if unbalanced
- If any subtree returns `-1`, propagate it upward

This avoids repeated height calculations.

---

## Algorithm
1. Call DFS from the root.
2. At each node:
   - Get left and right subtree heights.
   - If either is `-1`, return `-1`.
   - If height difference > 1, return `-1`.
   - Otherwise return `1 + max(leftHeight, rightHeight)`.
3. If final DFS result is `-1`, tree is not balanced.

---

## Java Implementation

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return dfs(root) != -1;
    }

    private int dfs(TreeNode node) {
        if (node == null) {
            return 0;
        }

        int leftHeight = dfs(node.left);
        if (leftHeight == -1) return -1;

        int rightHeight = dfs(node.right);
        if (rightHeight == -1) return -1;

        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }

        return 1 + Math.max(leftHeight, rightHeight);
    }
}
Complexity Analysis
Time Complexity: O(N)

Space Complexity: O(H)

Notes
Height is counted in number of nodes.

The tree is balanced only if all subtrees satisfy the balance condition.
