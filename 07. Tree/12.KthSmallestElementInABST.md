# 230. Kth Smallest Element in a BST
Medium


Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.

 

Example 1:
```
Input: root = [3,1,4,null,2], k = 1
Output: 1
```
Example 2:
```
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
 ```

Constraints:

- The number of nodes in the tree is n.
- 1 <= k <= n <= 10<sup>4</sup>
- 0 <= Node.val <= 10<sup>4</sup>
 

### Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?

## Approach
```
- Recursion
- inorder traversal gives nodes in sorted order of a BST
- ans[] -> store the answer and k in the second index
- decrement ans[1] until it become 0
  - when it become zero, that node is the ans
```

# Kth Smallest Element in a BST

## Problem
Given the root of a Binary Search Tree (BST) and an integer `k`,
return the kth smallest element in the tree.

---

## Key Insight
In a BST, **inorder traversal (Left → Root → Right)** produces values in sorted order.

Therefore:
- The kth smallest element is the **kth node visited during inorder traversal**.

---

## Optimized Approach (Inorder Traversal with Counter)

Instead of storing all elements:
- Perform inorder traversal
- Maintain a counter
- When counter reaches `k`, record the value

This avoids unnecessary storage and may stop early.

---

## Algorithm
1. Initialize:
   - `count = 0`
   - `result = 0`
2. Perform inorder traversal:
   - Traverse left subtree
   - Increment count
   - If count equals `k`, store the value
   - Traverse right subtree
3. Return `result`

---

## Java Implementation (Recursive)

```java
class Solution {
    private int count = 0;
    private int result = 0;

    public int kthSmallest(TreeNode root, int k) {
        inorder(root, k);
        return result;
    }

    private void inorder(TreeNode node, int k) {
        if (node == null) return;

        inorder(node.left, k);

        count++;
        if (count == k) {
            result = node.val;
            return;
        }

        inorder(node.right, k);
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(N)
- Space Complexity: O(N)
```
