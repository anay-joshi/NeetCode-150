# 199. Binary Tree Right Side View
Medium


Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

 

Example 1:

```
Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
```
Example 2:
```
Input: root = [1,null,3]
Output: [1,3]
```
Example 3:
```
Input: root = []
Output: []
 ```

Constraints:

- The number of nodes in the tree is in the range [0, 100].
- -100 <= Node.val <= 100

# Binary Tree Right Side View

## Problem
Given the root of a binary tree, return the values of the nodes visible
when the tree is viewed from the right side.

---

## Key Insight
From the right side, **only one node per level is visible**:
- the **rightmost node** of that level.

This can be efficiently obtained using **Breadth-First Search (BFS)**.

---

## Approach (BFS – Level Order)

- Traverse the tree level by level using a queue.
- For each level:
  - Process exactly `queue.size()` nodes.
  - The **last node processed** at that level is the rightmost node.
- Add that node’s value to the result list.

---

## Algorithm
1. If the root is null, return an empty list.
2. Initialize a queue and add the root.
3. While the queue is not empty:
   - Store the current `levelSize`.
   - Iterate `levelSize` times:
     - Remove a node from the queue.
     - If it is the last node of the level, add its value to the result.
     - Add its left and right children to the queue if they exist.
4. Return the result list.

---

## Java Implementation

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Queue<TreeNode> queue = new ArrayDeque<>();

        if (root != null) queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();

            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();

                if (i == levelSize - 1) {
                    result.add(node.val);
                }

                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
        }

        return result;
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(N)
- Space Complexity: O(N)
```
