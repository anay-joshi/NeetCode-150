# 153. Find Minimum in Rotated Sorted Array
Medium


Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = `[0,1,2,4,5,6,7]` might become:

- `[4,5,6,7,0,1,2]` if it was rotated 4 times.
- `[0,1,2,4,5,6,7]` if it was rotated 7 times.

Notice that rotating an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array nums of unique elements, return the minimum element of this array.

You must write an algorithm that runs in O(log n) time.

 

Example 1:
```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```
Example 2:
```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```
Example 3:
```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
 ```

Constraints:

- n == nums.length
- 1 <= n <= 5000
- -5000 <= nums[i] <= 5000
- All the integers of nums are unique.
- nums is sorted and rotated between 1 and n times.

## Approach


## Find Minimum in Rotated Sorted Array — Revision Notes

## Problem Summary
- Array is originally sorted in ascending order
- It is rotated between 1 and n times
- All elements are unique
- Return the minimum element
- Required time complexity: O(log n)

---

## Key Observations
- Rotation splits the array into two sorted halves
- There is exactly one point where order breaks
- The minimum element lies at this break
- At any step, one half of the array is always sorted

---

## Binary Search Strategy
- Use binary search to discard half of the array at each step
- Compare the middle element with the rightmost element

### Case 1
nums[mid] > nums[right]

scss
Copy code
- Middle lies in the left (larger) sorted portion
- Minimum is in the right half

left = mid + 1

shell
Copy code

### Case 2
nums[mid] <= nums[right]

scss
Copy code
- Middle lies in the right (smaller) sorted portion
- Minimum can be at mid or to the left

right = mid

yaml
Copy code

> ⚠️ Do NOT use `right = mid - 1`  
> `mid` itself could be the minimum element

---

## Termination Condition
- Continue while `left < right`
- When `left == right`, this index points to the minimum element

---

## Correct Pseudocode
left = 0
right = n - 1

while left < right:
mid = left + (right - left) / 2

sql
Copy code
if nums[mid] > nums[right]:
    left = mid + 1
else:
    right = mid
return nums[left]

yaml
Copy code

---

## Correct Java Template

while (left < right) {
    int mid = left + (right - left) / 2;

    if (nums[mid] > nums[right]) {
        left = mid + 1;
    } else {
        right = mid;
    }
}

## Mental Model (Easy to Remember)

nums[mid] > nums[right] → minimum is right side

nums[mid] <= nums[right] → minimum is left side (including mid)

Loop ends → left is the smallest element

return nums[left];

## Complexity
Time Complexity: O(log n)

Space Complexity: O(1)

Common Mistakes
Using right = mid - 1

Forgetting that mid itself can be the answer

Overcomplicating comparisons with nums[left]

One-Line Recall Rule
If nums[mid] > nums[right] → minimum is on the right
Else → minimum is at mid or on the left



## Solution
```java

class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;

        while(left<right){
            int mid = left + (right-left)/2;

            if(nums[mid]>nums[right]){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }

        return nums[left];
    }
}

```
## Complexity Analysis
```
- Time Complexity: O(logN)
- Space Complexity: O(1)
```
