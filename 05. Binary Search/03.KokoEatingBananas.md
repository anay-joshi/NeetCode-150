# 875. Koko Eating Bananas
Medium


Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.

Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.

Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.

Return the minimum integer k such that she can eat all the bananas within h hours.

 

Example 1:
```
Input: piles = [3,6,7,11], h = 8
Output: 4
```
Example 2:
```
Input: piles = [30,11,23,4,20], h = 5
Output: 30
```
Example 3:
```
Input: piles = [30,11,23,4,20], h = 6
Output: 23
``` 

Constraints:

- 1 <= piles.length <= 10<sup>4</sup>
- piles.length <= h <= 10<sup>9</sup>
- 1 <= piles[i] <= 10<sup>9</sup>

## Approach
```
/*
APPROACH: Koko Eating Bananas (Binary Search on Answer)

1. Observation
   - Eating speed k ranges from 1 to max(piles).
   - For a fixed k, total hours needed is:
       sum( ceil(pile / k) ) for all piles.
   - If total hours <= h, then speed k is valid.

2. Key Insight
   - As k increases, total hours decreases.
   - This monotonic behavior allows binary search on k.

3. Binary Search Setup
   - left (min speed)  = 1
   - right (max speed) = max value in piles

4. Binary Search Logic
   - mid = candidate eating speed
   - If hours(mid) <= h:
       → mid is a valid speed
       → store answer
       → try smaller speed (right = mid - 1)
   - Else:
       → speed too slow
       → increase speed (left = mid + 1)

5. Hour Calculation
   - Use ceiling division:
       ceil(pile / k) = (pile + k - 1) / k
   - Use long to avoid integer overflow.

6. Result
   - Return the smallest valid speed found.
*/

```

## Solution
```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int res=0;
        int min=1, max=0;

        for(int pile: piles){
            max = Math.max(max,pile);
        }

        while(min<=max){
            int mid = min + (max-min)/2;          
            if(calculateHours(piles,mid)<=h){
                res=mid;
                max=mid-1;
            }
            else{
                min=mid+1;
            }
        }

        return res;
    }

    public long calculateHours(int[] piles, int mid){
        long hours = 0;
        for(int pile: piles){
            hours+= (pile+mid-1)/mid;
        }

        return hours;
    }
}
```

## Complexity Analysis
```
- Time Complexity:  O(n*logm), m: max(piles)
- Space Complexity: O(1)
```
