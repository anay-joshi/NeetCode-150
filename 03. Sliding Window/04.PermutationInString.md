# 567. Permutation in String
Medium


Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.

In other words, return true if one of s1's permutations is the substring of s2.

 

Example 1:
```
Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
```
Example 2:
```
Input: s1 = "ab", s2 = "eidboaoo"
Output: false
 ```

Constraints:

- 1 <= s1.length, s2.length <= 10<sup>4</sup>
- s1 and s2 consist of lowercase English letters.

## Key Observations
```
A permutation of s1 must have the same character frequencies as s1.
The problem boils down to checking if any substring of s2 has the same character frequency as s1.
```

## Intuition Behind the Solution
```
The sliding window technique allows us to efficiently compare character frequencies in substrings of s2 with s1. Here's the approach:

Use a dictionary to count character frequencies for s1.
Maintain a window of size len(s1) on s2 and keep track of character frequencies in that window.
Slide the window across s2, updating the character counts and comparing them to s1's counts.
```

## Example Walkthrough
```
Input:

s1 = "ab"
s2 = "eidbaooo"
Step 1: Initialization
s1_count = {'a': 1, 'b': 1}
s2_count = {'e': 1, 'i': 1} (first window in s2)
Step 2: Sliding the Window
Letâ€™s slide the window across s2 while updating s2_count and checking for a match with s1_count.

Window: "ei"

s2_count = {'e': 1, 'i': 1}
Match? No
Window: "id"

Add d: s2_count = {'i': 1, 'd': 1, 'e': 0}
Remove e: Clean up e since its count is 0: s2_count = {'i': 1, 'd': 1}
Match? No
Window: "db"

Add b: s2_count = {'i': 1, 'd': 1, 'b': 1}
Remove i: Clean up i: s2_count = {'d': 1, 'b': 1}
Match? No
Window: "ba"

Add a: s2_count = {'d': 1, 'b': 1, 'a': 1}
Remove d: Clean up d: s2_count = {'b': 1, 'a': 1}
Match? Yes
At this point, the algorithm returns True because the substring "ba" is a permutation of s1.
```

## Solution
```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) {
            return false;
        }
        
        HashMap<Character, Integer> s1Count = new HashMap<>();
        HashMap<Character, Integer> s2Count = new HashMap<>();
        
        for (int i = 0; i < s1.length(); i++) {
            s1Count.put(s1.charAt(i), s1Count.getOrDefault(s1.charAt(i), 0) + 1);
            s2Count.put(s2.charAt(i), s2Count.getOrDefault(s2.charAt(i), 0) + 1);
        }
        
        if (s1Count.equals(s2Count)) {
            return true;
        }
        
        int left = 0;
        for (int right = s1.length(); right < s2.length(); right++) {
            char charRight = s2.charAt(right);
            s2Count.put(charRight, s2Count.getOrDefault(charRight, 0) + 1);
            
            char charLeft = s2.charAt(left);
            s2Count.put(charLeft, s2Count.get(charLeft) - 1);
            if (s2Count.get(charLeft) == 0) {
                s2Count.remove(charLeft);
            }
            
            left++;
            
            if (s1Count.equals(s2Count)) {
                return true;
            }
        }
        
        return false;        
    }
}
```
## Complexity Analysis:
```
Time Complexity:

Initializing s1_count and the first s2_count takes O(L1), where L1 is the length of s1.
Sliding the window across s2 takes O(L2), where L2 is the length of s2.
Overall: O(L1 + L2).
Space Complexity:

The dictionaries s1_count and s2_count store at most 26 keys (for each letter in the alphabet), resulting in O(1) space.
```
