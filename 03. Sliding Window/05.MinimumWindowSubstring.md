# [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)
Hard


Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".

The testcases will be generated such that the answer is unique.

A substring is a contiguous sequence of characters within the string.

 

Example 1:
```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```
Example 2:
```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```
Example 3:
```
Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
``` 

Constraints:
- m == s.length
- n == t.length
- 1 <= m, n <= 105
- s and t consist of uppercase and lowercase English letters.

## Approach
```
ðŸ§  Intuition
The problem is to find the smallest substring in s that contains all characters of t. This is a classic sliding window problem. The most efficient solution uses two pointers (left and right) and a frequency map. We first count the characters needed from t. We expand the window to the right until all required characters are present (count == needed). Once the window is valid, we try to shrink it from the left to find the minimum length. We track the character frequencies and use a single count variable to efficiently check the validity of the window.

ðŸš€ Approach
Pre-process the target string t to create a frequency map (map) of required characters.
Initialize pointers left=0, right=0, and tracking variables: count (to track how many characters required by t are currently satisfied), needed (total length of t), minLen, and start.
Expand Window (Right Pointer): Iterate with right, decrementing the frequency of s[right] in the map. If the frequency was initially greater than 0, it means we've satisfied a required character, so increment count.
Shrink Window (Left Pointer): While count == needed (window is valid):
Update minLen and start.
Shrink the window by moving left. Increment the frequency of s[left] in the map.
If the frequency becomes positive (>0), it means this character is now missing from the window, so decrement count.
Continue until right reaches the end of s.
Return the substring defined by the saved start and minLen.
```

## Solution
### Approach 1
```java
class Solution {
    public String minWindow(String s, String t) {
        int winS = 0, winE = 0;
        String ans = "";
        Map<Character, Integer> tMp = new HashMap<>();
        Map<Character, Integer> wMp = new HashMap<>();
        for(char c : t.toCharArray()) {
            tMp.put(c, tMp.getOrDefault(c, 0)+1);
        }
        while(winS < s.length() && winE < s.length()) {
            char c = s.charAt(winE);
            wMp.put(c, wMp.getOrDefault(c, 0)+1);
            while(winS <= winE && satisfy(wMp, tMp)) {
                if(ans == "")
                    ans = s.substring(winS, winE+1);
                ans = (winE-winS+1) < ans.length()?s.substring(winS, winE+1):ans;
                wMp.put(s.charAt(winS), wMp.get(s.charAt(winS))-1);
                if(wMp.get(s.charAt(winS)) == 0)
                    wMp.remove(s.charAt(winS));
                winS++;
            }
            winE++;
        }
        return ans;
    }

    private boolean satisfy(Map<Character, Integer> wMp, Map<Character, Integer> tMp) {
        for(char c : tMp.keySet()) {
            if(!wMp.containsKey(c) || wMp.get(c) < tMp.get(c))
                return false;
        }
        return true;
    }
}
```
### Approach 2 (Optimized)
```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";

        Map<Character, Integer> map = new HashMap<>();
        // **Target** frequency map
        for (char ch : t.toCharArray()) {
            map.put(ch, map.getOrDefault(ch, 0) + 1);
        }

        int start = -1;
        int count = 0;
        int needed = t.length();
        int left = 0;
        int minLen = Integer.MAX_VALUE;

        for (int right = 0; right < s.length(); right++) {
            char ch = s.charAt(right);
            
            if (map.containsKey(ch)) {
                // Check if this character was still needed
                if (map.get(ch) > 0) {
                    count++;
                }
                map.put(ch, map.get(ch) - 1); // Decrement frequency
            }

            // **Shrink** the window while it is valid
            while (count == needed) {
                // Update result
                if (minLen > right - left + 1) {
                    minLen = right - left + 1;
                    start = left;
                }
                
                char leftChar = s.charAt(left);
                if (map.containsKey(leftChar)) {
                    map.put(leftChar, map.get(leftChar) + 1);
                    // Check if this character is now missing
                    if (map.get(leftChar) > 0) {
                        count--;
                    }
                }
                left++;
            }
        }
        return minLen == Integer.MAX_VALUE ? "" : s.substring(start, start + minLen);
    }
}
```
## Complexity Analysis
```
Approach 1:
- Time Complexity: O(N*K), N: length of str, K: length of pattern
- Space Complexity: O(K), K: length of pattern
Approach 2:
- Time Complexity: O(N), N: length of str
- Space Complexity: O(K), K: length of pattern
```
