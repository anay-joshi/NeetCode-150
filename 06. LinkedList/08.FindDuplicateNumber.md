# 287. Find the Duplicate Number
Medium


Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.

You must solve the problem without modifying the array nums and uses only constant extra space.

 

Example 1:
```
Input: nums = [1,3,4,2,2]
Output: 2
```
Example 2:
```
Input: nums = [3,1,3,4,2]
Output: 3
 ```

Constraints:

- 1 <= n <= 105
- nums.length == n + 1
- 1 <= nums[i] <= n
- All the integers in nums appear only once except for precisely one integer which appears two or more times.
 

### Follow up:
- How can we prove that at least one duplicate number must exist in nums?
- Can you solve the problem in linear runtime complexity?

## Approach
## Core Idea
- Treat the array as a **linked list**
- Index = node
- Value = next pointer
- Duplicate value ⇒ **cycle exists**
- **Duplicate number = starting node of the cycle**

---

## Why Two Pointers (Slow & Fast)
- `slow` moves 1 step
- `fast` moves 2 steps
- If a cycle exists, they **must meet inside the cycle**

---

## Phase 1: Cycle Detection (First Loop)
- Start both pointers at `nums[0]`
- Move:
  - `slow = nums[slow]`
  - `fast = nums[nums[fast]]`
- When they meet, a cycle is confirmed
- ⚠️ Meeting point is **NOT** guaranteed to be the cycle start

---

## Phase 2: Find Cycle Start (Second Loop)
- Reset one pointer (`slow2`) to `nums[0]`
- Keep the other pointer (`slow`) at meeting point
- Move both **1 step at a time**
- Where they meet = **cycle start = duplicate number**

---

<img width="1000" height="750" alt="image" src="https://github.com/user-attachments/assets/a5c1374a-97a8-4133-b171-d656c6a456ca" />


## Distance Explanation (Why Reset Works)

Let:
- A = distance from start → cycle start
- B = distance from cycle start → meeting point
- C = cycle length

Movement:
Slow = A + B
Fast = A + B + C + B


Because fast moves twice:
2(A + B) = A + B + C + B
A = C


➡️ Distance from start to cycle start  
= distance from meeting point to cycle start

So both pointers meet at cycle start.

---

## Example
nums = [1, 3, 4, 2, 2]

Cycle: 2 → 4 → 2
Meeting point: 2
Cycle start: 2
Answer: 2


---

## Why Second Loop Is Required
- First loop only proves **cycle exists**
- Meeting point can be anywhere inside cycle
- Second loop is required to find **exact cycle entry**
- Cycle entry = duplicate element

---

## Edge Case Example
nums = [2,5,9,6,9,3,8,9,7,1]
First loop meets at: 7
Cycle start (duplicate): 9

---

## One-Line Interview Takeaway
> The first loop detects the cycle, the second loop finds the cycle’s entry, which is the duplicate number.
---

## When to Use This Trick
- n + 1 elements
- Values in [1, n]
- No modification allowed
- Constant extra space required
  

## Solution
```java
class Solution {
    public int findDuplicate(int[] nums) {
        
        int slow = nums[0], fast = nums[0];
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while(slow != fast);
        
        slow = nums[0];
        
        while(slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        
        return slow;
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(N)
- Space Complexity: O(1)
```
