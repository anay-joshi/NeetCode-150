# 287. Find the Duplicate Number
Medium


Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.

You must solve the problem without modifying the array nums and uses only constant extra space.

 

Example 1:
```
Input: nums = [1,3,4,2,2]
Output: 2
```
Example 2:
```
Input: nums = [3,1,3,4,2]
Output: 3
 ```

Constraints:

- 1 <= n <= 105
- nums.length == n + 1
- 1 <= nums[i] <= n
- All the integers in nums appear only once except for precisely one integer which appears two or more times.
 

### Follow up:
- How can we prove that at least one duplicate number must exist in nums?
- Can you solve the problem in linear runtime complexity?

## Approach
```
- slow and fast pointer, similar to cycle in link list
```

# Find the Duplicate Number (Floyd’s Cycle Detection)

## Problem
- Array size = n + 1
- Values range = [1, n]
- Exactly one number is duplicated
- Do NOT modify array
- Use O(1) extra space

---

## Core Insight
- Treat array as a **linked list**
- Index = node
- Value = next pointer
- Duplicate value ⇒ two pointers point to same index ⇒ **cycle exists**
- **Duplicate number = start of the cycle**

---

## Why Cycle Exists
- n + 1 nodes but only n possible next pointers
- Pigeonhole principle forces a loop
- Loop entry point corresponds to duplicate number

---

## Floyd’s Algorithm (Tortoise & Hare)

### Phase 1: Detect Cycle
- `slow = nums[slow]` (1 step)
- `fast = nums[nums[fast]]` (2 steps)
- They must meet if cycle exists

### Phase 2: Find Cycle Start
- Reset one pointer to `nums[0]`
- Move both pointers **1 step at a time**
- Meeting point = **duplicate number**

---

## Distance Intuition (Key Formula)
Let:
- A = distance from start → cycle start
- B = distance from cycle start → meeting point
- C = cycle length

From math:
2(A + B) = A + B + kC
A = kC - B

yaml
Copy code

- Distance from meeting point → cycle start = `C - B`
- Extra loops (`kC`) don’t change position
- Both pointers reach cycle start together

---

## Example
nums = [1, 3, 4, 2, 2]

Links:
0 → 1 → 3 → 2 → 4 → 2

Cycle start = 2
Duplicate = 2

yaml
Copy code

---

## Complexity
- Time: O(n)
- Space: O(1)

---

## One-Line Interview Intuition
> Because values are in [1, n], the array forms a linked list with a cycle, and the duplicate number is the cycle’s entry point.

---

## When to Use This Trick
- n + 1 elements
- Values in [1, n]
- No modification allowed
- Constant extra space required
  

## Solution
```java
class Solution {
    public int findDuplicate(int[] nums) {
        
        int slow = nums[0], fast = nums[0];
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while(slow != fast);
        
        slow = nums[0];
        
        while(slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        
        return slow;
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(N)
- Space Complexity: O(1)
```
