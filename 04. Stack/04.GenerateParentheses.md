# 22. Generate Parentheses
Medium


Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

 > Feels like mismatch for the pattern satck 

Example 1:
```
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
```
Example 2:
```
Input: n = 1
Output: ["()"]
 ```

Constraints:

- 1 <= n <= 8

## Approach
<img width="1000" height="726" alt="image" src="https://github.com/user-attachments/assets/2bbef28e-8208-4e4e-9a04-3f526e124d93" />


```
- Backtracking
How it works
First of all, we start

number of open parenthese: 0
number of close parenthese: 0
Increase open until we reach n.

open: 1
close: 0
parenthese: (
Increase open until we reach n.

open: 2
close: 0
parenthese: ((
Now we reach n, then increase close until we reach n

open: 2
close: 1
parenthese: (()
Increase close until we reach n

open: 2
close: 2
parenthese: (())
Now we succeefully created one of well-formed parentheses.

res = ["(())"]
Now we have 2 open and 2 close, so let's go back to 1 open and 0 close, so that we can move in different way.

open: 1
close: 0
parenthese: (
Increase close to move in a different way.

open: 1
close: 1
parenthese: ()
Now we have 1 open. We will increase open until n.

open: 2
close: 1
parenthese: ()(
Now we reach n with 2 open. Then increase close until n.

open: 2
close: 2
parenthese: ()()
We successfully created one of well-formed parentheses.

return res (= ["(())","()()"])


Full flow:

1. Define the generateParenthesis function
res = []
Initialization: We initialize an empty list res to store the valid combinations.
2. Define the dfs function
def dfs(openP, closeP, s):
Purpose: This is a helper function that uses depth-first search (DFS) to explore all possible combinations.
Parameters:
openP: The current number of open parentheses used.
closeP: The current number of close parentheses used.
s: The current string being built.
3. Base Case
if openP == closeP and openP + closeP == n * 2:
    res.append(s)
    return
Condition: If the number of open and close parentheses are equal and the total length of the string is 2 * n, it means we have a valid combination.
Action: Append the valid combination s to the result list res and return.
4. Recursive Case: Adding an Open Parenthesis
if openP < n:
    dfs(openP + 1, closeP, s + "(")
Condition: If the number of open parentheses used (openP) is less than n, we can add another open parenthesis.
Action: Recursively call dfs with one more open parenthesis, and append ( to the current string s.
5. Recursive Case: Adding a Close Parenthesis
if closeP < openP:
    dfs(openP, closeP + 1, s + ")")
Condition: If the number of close parentheses used (closeP) is less than the number of open parentheses, we can add a close parenthesis to maintain balance.
Action: Recursively call dfs with one more close parenthesis, and append ) to the current string s.
6. Initial Call to dfs
dfs(0, 0, "")
Purpose: Start the recursive process by calling dfs with zero open and close parentheses, and an empty string s.
7. Return the Result
return res
Purpose: Return the list res containing all valid combinations of well-formed parentheses.


Complexity
Time complexity:O(2^2n)
Space complexity: O(n)
```

## Solution
```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();

        dfs(0,0,"",n,res);

        return res;
    }

    public void dfs(int openP, int closeP, String s, int n, List<String>res){
        if(openP==closeP && openP+closeP==n*2){
            res.add(s);
            return;
        }

        if(openP<n){
            dfs(openP+1,closeP,s+"(",n,res);
        }

        if(closeP<openP){
            // above condition is not equal since, you are increasing count and adding para at the same time
            dfs(openP,closeP+1,s+")",n,res);
        }
    }
}
```
