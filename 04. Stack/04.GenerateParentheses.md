# 22. Generate Parentheses
Medium


Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

 > Feels like mismatch for the pattern satck 

Example 1:
```
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]
```
Example 2:
```
Input: n = 1
Output: ["()"]
 ```

Constraints:

- 1 <= n <= 8

## Approach
<img width="1000" height="726" alt="image" src="https://github.com/user-attachments/assets/2bbef28e-8208-4e4e-9a04-3f526e124d93" />


```
Intuition :
We can generate each combination by making recursive choices to add either an opening ( or a closing ) parenthesis, ensuring that:

We never add more than n opening or n closing parentheses.
The number of closing parentheses never exceeds the number of opening ones at any point.
Approach :
Recursive Backtracking:
Start with an empty string and use two counters: open_count for ( and close_count for ).
At each recursive step, add ( if open_count is less than n.
Add ) if close_count is less than open_count to maintain the balance.
If both open_count and close_count reach n, the current combination is complete and valid.
Base Case:
When both open_count and close_count equal n, add the string to the result list.
Pruning:
If open_count exceeds n or close_count exceeds open_count, terminate that branch of recursion to avoid invalid combinations.


Complexity
Time complexity:O(2^2n)
Space complexity: O(n)
```

## Solution
```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        backtrack(result, "", 0, 0, n);
        return result;
    }
    
    private void backtrack(List<String> result, String current, int openCount, int closeCount, int n) {
        if (openCount == n && closeCount == n) {
            result.add(current);
            return;
        }
        
        if (openCount < n) {
            backtrack(result, current + "(", openCount + 1, closeCount, n);
        }
        if (closeCount < openCount) {
            backtrack(result, current + ")", openCount, closeCount + 1, n);
        }
    }
}
```
