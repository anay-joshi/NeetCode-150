# [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)
Hard


Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.

 

Example 1:
```
Input: heights = [2,1,5,6,2,3]
Output: 10
Explanation: The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.
```
Example 2:
```
Input: heights = [2,4]
Output: 4
 ```

Constraints:

- 1 <= heights.length <= 105
- 0 <= heights[i] <= 104

## Approach
```
üß† Intuition (Core Idea)

Every bar in the histogram wants to expand left and right until a smaller bar blocks it.

Brute force checks all expansions ‚Üí O(n¬≤) ‚ùå

Key insight:

A bar‚Äôs maximum rectangle is determined when a smaller bar appears.

So:
üëâ When height decreases, we must finalize rectangles of taller bars.

üöÄ Approach (Monotonic Stack)

Use a monotonic increasing stack (by height).

Stack stores:

(startIndex, height)


startIndex = furthest left this height can extend.

üîÅ Algorithm Steps

Initialize empty stack and maxArea = 0.

Iterate through heights:

Set start = current index

While stack top height > current height:

Pop (index, height)

Area = height √ó (currentIndex ‚àí index)

Update maxArea

Update start = index (important!)

Push (start, currentHeight)

After loop:

For all remaining stack elements:

Area = height √ó (n ‚àí index)

Update maxArea

Return maxArea

üîë Why startIndex Matters

When popping taller bars, the current shorter bar can extend as far left as the popped bar did.

This preserves the correct width for future rectangles.

üì¶ Stack Invariant (Very Important)

Stack heights are always increasing

Each bar is:

Pushed once

Popped once

‚Üí O(n) time

‚è±Ô∏è Complexity

Time: O(n)

Space: O(n)
```

## Solution
```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<int[]>stack = new Stack<>();
        int maxArea = 0;
        int n = heights.length;

        for(int i=0; i<n; i++){
            int start = i;

            while(!stack.isEmpty() && stack.peek()[1]>heights[i]){
                int[] popped = stack.pop();
                int index = popped[0];
                int height = popped[1];
                maxArea = Math.max(maxArea, height*(i-index));
                start = index;
            }

            stack.push(new int[]{start,heights[i]});
        }

        for(int[] bar: stack){
            int height = bar[1];
            int index = bar[0];

            maxArea = Math.max(maxArea,height*(n-index));
        }

        return maxArea;
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(N)
- Space Complexity: O(N)
```
